### 1.项目使用的框架

Spring data JPA、Spring boot、Spring data Jedis

### 2.有什么优化

### 3.项目遇到的坑

* 缓存不命中时查询数据库，由于是被动缓存，被人利用这个漏洞攻击了。导致数据库连接池占满。解决办法是不命中也缓存一个特殊值“&&”，过期时间较短

* 自己实现阻塞操作时，CPU占用率特别高，sleep(1) 后马上降下来了。

* 缓存集中失效引起的数据库压力。解决办法是设置过期时间+随机值

### 3.1 并发中遇到哪些问题

死锁产生条件：互斥条件，请求与保持条件，不剥夺条件，循环等待条件



### 3.2 职业规划

希望自己将来可以造轮子给别人用。


### 3.3 说说你项目中印象比较深刻的bug

  同3

### 4.如何在项目中使用缓存

读多改少的情况用二级缓存

否则用Redis缓存

### 5.公司项目流程图

### 6.mq在项目中如何使用

   替代部分分布式事务问题，能达到最终一致性

   更新每台机器的一级缓存

### 7.hash一致性分片的好处

### 8.HashMap源码

### 9.put流程

put()方法返回的是`oldValue`或者`null`

```
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }

```

` << ` : 左移运算符，num << 1,相当于num乘以2

` >> ` : 右移运算符，num >> 1,相当于num除以2

` >>> `: 无符号右移，忽略符号位，空位都以0补齐

` & `  : 与, 两个操作数中位都为1，结果才为1，否则结果为0

` ~ `  : 非, 就是返回数值的反码，如果位为0，结果是1，如果位为1，结果是0

` | `  : 或, 两个位只要有一个为1，那么结果就是1，否则就为0

` ^ `  : 异或, 两个操作数的位中，相同则结果为0，不同则结果为1

### 10.线程的5种状态如何切换

线程的5种状态：新建、就绪、运行、阻塞、死亡。

切换：
sleep() :

yield() : 暂停当前正在执行的线程对象，并执行其他线程。

join()  : Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。join() 方法主要是让调用该方法的thread完成run方法里面的东西后， 再执行join()方法后面的代码

扩展：

Object类的wait(), notify(), notifyAll()方法

wait()

Object的wait方法有三个重载方法，其中一个方法wait() 是无限期(一直)等待，直到其它线程调用notify或notifyAll方法唤醒当前的线程；另外两个方法wait(long timeout) 和wait(long timeout, int nanos)允许传入 当前线程在被唤醒之前需要等待的时间，timeout为毫秒数，nanos为纳秒数。

notify()

notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。

notifyAll()

notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。


### 11.线程是否可以重复启动，会有什么后果。

单一线程不能重复启动，否则报`IllegalThreadStateException`

扩展：

Thread.interrupt()方法不会中断一个正在运行的线程。这一方法实际上完成的是，在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，那么，它将接收到一个中断异常（InterruptedException），从而提早地终结被阻塞状态。

### 12.synchronized 和 lock的区别

ReentrantLock 相对于固有锁synchronized，同样是可重入的，在某些vm版本上提供了比固有锁更高的性能，提供了更丰富的锁特性，比如可中断的锁，可等待的锁，平等锁以及非块结构的加锁。从代码上尽量用固有锁，jvm会对固有锁做一定的优化，并且代码可维护和稳定。只有在需要ReentrantLock的一些特性时，可以考虑用ReentrantLock实现。

### 13.悲观锁、乐观锁，如何自己实现一个乐观锁

乐观锁是假设我已经拿到锁，悲观所是我必须拿到锁，前者用CAS，后者用mutex。

### 14.spring aop底层实现方式

动态代理

### 15.spring事务的实现原理

所谓事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。Spring 支持 7 种事务传播行为：

PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。

PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。

PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。

PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。

PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。

PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与

PROPAGATION_REQUIRED 类似的操作。

### 16.

### 17.http请求可能返回的状态码

### 18.post和get的区别

GET用于信息获取，而且应该是安全的和幂等的。

GET请求的数据会附在URL之后

POST表示可能修改变服务器上的资源的请求。

POST把提交的数据则放置在是HTTP包的包体中。

### 19.如何分辨一个对象是否为垃圾

可达性分析算法

这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。

在Java语言中,可作为GC Roots的对象包括下面几种:

* 虚拟机栈(栈帧中的本地变量表)中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中JNI(即一般说的Native方法)引用的对象。

即使在可达性分析算法中不可达的对象,也并非是“非死不可”的,这时候它们暂时处于“缓刑”阶段,要真正宣告一个对象死亡,至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)


### 20.是否可以手动回收

不能手动回收，只能建议

### 21.不可以手动回收，这个方法有什么用

### 22.手写单例

### 23.学生表，班级学生关系表，查出所有班级学生大于90分的个数大于10的班级。

### 24.链表的逆转

### 25.一次循环查找出字符串中第一个不重复的字符

### 26.为何离职

### 27.自身优势

### 28.Mysql执行计划

### 29.慢sql

### 30.快排，堆排，归并排序，基数排序

### 31.线程的生命周期

### 32.单例在哪些场景中用到

### 33.线程启动的底层实现

### 34.wait()方法是哪个类的，为什么不把wait()方法放在Thread类，而是Object？

### 35.线程的实现方式

继承Thread类

实现Runnable接口

使用Executor framework (这会创建一个线程池)

### 36.线程池底层是怎么实现的


### 37.线程的两种创建方式

继承Thread类

实现Runnable接口

实现Callable<>接口(配合FutureTask类，用Thread类启动，Callable接口的call()方法带返回值)

采用继承Thread类方式：

- 1 优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。
- 2 缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。不能够很好的体现数据共享。

采用实现Runnable接口方式：
- 1 优点： 线程类只是实现了Runable接口，还可以继承其他的类。 可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况。能够很好的体现数据共享。
- 2 缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。

### 38.讲讲线程池coreSize和max的关系

int corePoolSIze，核心池大小，也就是线程池中会维持不被释放的线程数量。

maximumPoolSize，线程池的最大线程数，代表着线程池中能创建多少线程池。

### 39.线程池拒绝策略

* ThreadPoolExcutor.AbortPolicy()——直接抛出异常，默认操作
* ThreadPoolExcutor.CallerRunsPolicy()——只用调用者所在线程来运行任务
* ThreadPoolExcutor.DiscardOldersPolicy()——丢弃队列里最近的一个任务，并执行当前任务
* ThreadPoolExcutor.DiscardPolicy()——不处理，直接丢掉

### 40.二分查找

### 41.二叉排序树

### 42.在main方法中怎么调用单例实例

### 43.反射原理

### 44.spring ioc原理

### 45.TCP协议3次握手，4次挥手

### 45.1 TCP为什么是可靠的

### 46.SQL group by、having

### 47.数据库索引

### 48.java集合

### 49.List有哪些实现类，并描述数据结构，Map有哪些实现类，并描述数据结构

### 50.数据库索引

### 51.重写equals方法一定要重写hashcode方法吗

### 52.jvm启动时发生了那些事

### 53.HashMap和HashTable的区别。

HashMap不是线程安全的，HashTable是线程安全的一个Collection,HashMap允许null key和null value，而hashtable不允许。

### 54.TCP窗口是什么

### 55.TCP为什么比UDP慢

### 56.一个用户表 1亿条记录，如何快速找出某1万用户

### 57.算法：链表相交

### 58.如何避免HashMap resize

### 59.画一下线程的流程图

### 60.算法：一中间高两边低的数组找出峰值

### 61.一个数组，有两个数只出现一次，其他元素都出现两次以上，找出这两个数

### 62.HashMap实现原理，get的时间复杂度

### 63.spring 动态代理

### 64.CPU内存和缓存的工作方式

### 65.java 类加载机制

### 66.mysql递归树查询实现语句

### 67.cglib和jdk proxy区别

jdk动态代理是由java内部的**反射机制**来实现的，cglib动态代理底层则是借助asm（ASM是一个java字节码操纵框架）来实现的。总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。

扩展：java动态代理和静态代理

按照代理的创建时期，代理类可以分为两种：

静态：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。

动态：在程序运行时运用反射机制动态创建而成。

### 68.类锁，对象锁

### 69.异常结构物

### 70.事务的隔离级别和特性，情景分析

事务的四大特性：

* 原子性（Atomicity）

* 一致性（Consistency）

* 隔离性（Isolation）

* 持久性（Durability）

事务的隔离级别：

数据库事务的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。

*注：MySQL的默认隔离级别就是Repeatable read。*

### 71.LinkedHashMap使用场景

实现LRU Cache

### 72.ThreadLocal 应用场景

比如在多线程环境下使用SimpleDateFormat

### 73.同一进程的不同线程，哪些内容可以共享

Heap

### 74.字符串格式化，去掉首尾的空格，以及字符串中间连续的空格，但中间的只保留最后一个空格。比如： " i love meituan ",格式化后："ilove meituan”.

### 75.常用linux命令

### 76.单例模式的双重检查锁定写法

### 77.zookeeper原理

### 78.linux软连接和硬链接，如何查看cpu，内存，java。awk，top

### 79.数据库索引，复合索引

### 80.StringBuffer和StringBuilder的区别

StringBufferd支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用

### 81.螺旋矩阵算法

### 82.jvm调试，内存优化

禁用System.gc()

开启JIT编译

### 83.Spring @Autowire和@Resource的区别

在@Autowire使用时，默认使用by-Type的方式进行注入(类名注入)

而@Resource，默认使用by-Type的方式注入，但使用by-Name方式时，相比@Autowire较方便(类名和注解名注入)

@Autowire用于属性、构造器、多参数方法注入，可以通过@Qualifer变为by-Name方式

@Resource则支持属性、setter方法上的使用：如果名字没有明确指定，默认名从那个字段名或者方法名中推断出。如果是字段，就获取这个字段名；如果是setter方法，其获取bean的属性名。

所以，你在注入构造器与多参数方法时，请使用@Autowire与@Qualifer进行配合

### 84.URL长度限制

http协议不限制，各厂商浏览器限制

### 85.volitile关键字作用

### 86.java 深克隆浅克隆

### 87.算法：查找链表倒数第K个节点

--------------------------------------------------------

### 88.spring 模块划分

### 89.应用上下文的集中实现方式

### 90.FutureTask的实现原理

### 91.awk实现文件合并

### 92.mysql 的锁

### 93.FactoryBean和BeanFactory的区别

### 94.HashMap和ConcurrentHashMap的线程安全问题

### 95.数据库事务的CAS

### 96.约瑟夫环的编程

### 97.中国有100G数据，美国有100G数据，如何对比数据是否一致？

### 98.如何判断链表是否有环

### 99.找出数组中第K大的数

### 100.java中的引用有几种?

4种。

* 强引用：强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。

* 弱引用：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象

* 虚引用：如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收

* 软引用：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。

### 101.Java中的threadlocal是怎么用的? threadlocal中的内部实现是怎么样的? 哪种引用?

### 102.java中的"final"关键字在多线程的语义中，有什么含义

### 103.说说nio的架构，为什么变快了，说说select和buffer都是怎么用的？

  1.在操作系统中的实现原理? 如果都是cpu轮训话，会不会对cpu影响太大?
  2.应用到了linux中的什么特性?

### 104.nio中， 如果不显式的调用 system.gc() 那会出现什么问题？

### 105.jvm的垃圾回收分为哪些种类？每一种都是怎么去实现的？讲述一下G1的回收策略？

### 106.jvm中的参数分为哪些种类，都是做什么的？jvm的监控怎么做？实际项目上线以后的监控怎么做？

### 107.JVM中，如果把堆内存参数配置的超过了本地内存，会怎么样？

### 108.JVM中的内存结构分为哪些方面？

### 109.栈空间是怎么样的？每个线程只有一个栈吗？

### 110.栈空间的内部结构是怎么样的？

### 111.堆内存为什么要设计为分代？

### 112.ArrayList的实现原理，如何测试ArrayList动态分配内存中带来的内存、cpu变化

### 113.ArrayList是不是线程安全的? 怎么实现线程安全的?

ArrayList是线程不安全的，Vector是线程安全的，在方法上添加synchronized实现。

### 114.

### 115.volatile的作用，如果volatile修饰的对象经过了大量的写，会出现什么问题？

并发环境中确保可见性、顺序性和一致性

### 116.String的+和StringBuilder有什么区别? 放在循环中有什么问题？

String对象一经创建就不可以修改，所以String+会产生多个对象，在循环中会产生大量垃圾对象。

StringBuilder是字符数组实现的,利用append实现字符串追加，是一个对象。

### 117.日志打印的过程中，使用String的+操作和使用占位符输出，对性能上有什么区别

### 117.SimpleDateFormat如果是一个全局变量的话，有什么问题？

SimpleDateFormat是非线程安全的

### 118.HashMap的操作中，直接使用keySet()遍历有什么问题

效率低，建议使用EntrySet

### 119.linux中awk命令的使用？

awk -f ",|=" "{print $0}"

### 120.nginx是多线程还是单线程？

Nginx分为单工作进程和多工作进程两种模式。在单工作进程模式下，除主进程外，还有一个工作进程，工作进程是单线程的；在多工作进程模式下，每个工作进程包含多个线程。Nginx默认为单工作进程模式。

### 121.linux中如何监控和查看内存、cpu情况？

### 122.负载分为哪些类别和层次？你们项目中是怎么用的？

### 123.mq是如何使用的？

同6#

### 124.http协议建立连接的过程是怎么样的？

### 125.https建立连接的的过程是怎么样的？

### 126.forward和redirect有什么区别？

forward服务端内部跳转，客户端无感知。redirect客户端重定向。

### 127.linux如何实现nginx的高性能？有什么特性被应用了？直接来说，就是基于linux的网络编程

### 128.数据流的锁级别，乐观锁和悲观锁的概念，是不是只有悲观锁？

### 129.数据库如何实现事务？

### 130.有没有什么研究深入的技术，或者比较满意的项目？

### 131.CopyOnWriteArrayList 应用场景

那么有没有办法在遍历一个list的时候，还向list中添加元素呢？办法是有的。就是java concurrent包中的CopyOnWriteArrayList。

CopyOnWriteArrayList类最大的特点就是，在对其实例进行修改操作（add/remove等）会新建一个数据并修改，修改完毕之后，再将原来的引用指向新的数组。这样，修改过程没有修改原来的数组。也就没有了ConcurrentModificationException错误。

### 132.如何合理的配置java线程池？如CPU密集型的任务，基本线程池应该配置多大？IO密集型的任务，基本线程池应该配置多大？用有界队列好还是无界队列好？任务非常多的时候，使用什么阻塞队列能获取最好的吞吐量？

* 配置线程池时CPU密集型任务可以少配置线程数，大概和机器的cpu核数相当，可以使得每个线程都在执行任务

* IO密集型时，大部分线程都阻塞，故需要多配置线程数，2*cpu核数

* 有界队列和无界队列的配置需区分业务场景，一般情况下配置有界队列，在一些可能会有爆发性增长的情况下使用无界队列

* 任务非常多时，使用非阻塞队列使用CAS操作替代锁可以获得好的吞吐量。


### 133.如何使用阻塞队列实现一个生产者和消费者模型？请写代码。

生产者负责notify，消费者需要wait，条件是有无元素

BlockingQueue put take

### 134. 如何实现乐观锁（CAS）？如何避免ABA问题？

读取内存值

比较内存值和期望值

替换内存值为要替换值

利用CPU的CAS命令，避免ABA需要使用类似于version，AtomicStampedReference也可以

### 135. 读写锁可以用于什么应用场景？

多读少写，读写锁支持多个读操作并发执行，写操作只能由一个线程来操作

### 136. 什么时候应该使用可重入锁？

重入锁指的是在某一个线程中可以多次获得同一把锁，在线程中多次操作有锁的方法。

需要使用除了内置锁以外的锁特性，比如可中断，可等待的锁，平等锁等

可轮询，可中断，定时，非块，公平队列等高级特性时候使用可重入锁

### 137.什么场景下可以使用volatile替换synchronized？

volatile适用于新值不依赖于就值的情形。

1写N读

单线程修改变量或不依赖当前值，且不与其他变量构成不变性条件时候使用volatile

### 138.为什么Thread类的sleep()和yield()方法是静态的？

Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。

### 139.为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？

当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。

### 140. ajax方法请求数据返回301会引起重定向吗？
