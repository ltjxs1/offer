### 1.尽量指定类、方法的final修饰符

### 2.尽量重用对象

### 3.尽可能使用局部变量

### 4.及时关闭流

### 5.尽量减少对变量的重复计算

例如，将

```
for (int i = 0; i < list.size(); i++) {
  ...
}
```
替换为：

```
for (int i = 0, int length = list.size(); i < length; i++) {
  ...
}
```

### 6.尽量采用懒加载的策略，即在需要的时候才创建

例如，将

```
String str = "aaa";
if (i == 1){
 list.add(str);
}
```
替换为：

```
if (i == 1){
    String str = "aaa";
    list.add(str);
}
```

### 7.慎用异常

异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。

### 8.不要在循环中使用try {} catch {}，应该把其放在最外层

### 9.如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度

比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：

- （1）StringBuilder()　　　　　　// 默认分配16个字符的空间
- （2）StringBuilder(int size)　　// 默认分配size个字符的空间
- （3）StringBuilder(String str)　// 默认分配16个字符+str.length()个字符空间

　　可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：

　　（1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间

　　（2）把原来的4096个字符拷贝到新的的字符数组中去

　　这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。

### 10.当复制大量数据时，使用System.arraycopy()命令

### 11.乘法和除法使用移位操作

### 12.尽量避免随意使用静态变量

当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的

### 13.实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历

　　这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。

foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。

### 14.将常量声明为static final，并以大写命名

这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量

### 15.顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList

### 16.把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+”"最慢

- 1）String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断
- 2）Integer.toString()方法就不说了，直接调用了
- 3）i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串

### 17.使用最有效率的方式去遍历Map

假如只想遍历Map的key，则调用 keySet()比较合适.

假如遍历key和value，则调用entrySet()最合适.
