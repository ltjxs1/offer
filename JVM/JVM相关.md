### 1.什么情况会造成内存泄露

1) 当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：
```
public class A{
   private static B b = new B();
}
```

2) static map，用一个对象作为key，然后修改了这个对象，导致hash变了，结果用之前那个对象作为key去取，取不到


### 2.在java中wait和sleep方法的不同？

- 等待时wait会释放锁，而sleep一直持有锁。
- wait通常被用于线程间交互，sleep通常被用于暂停执行。
- wait属于Object方法，sleep属于Thread方法。

### 3.如何分辨一个对象是否为垃圾

可达性分析算法

这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。

在Java语言中,可作为GC Roots的对象包括下面几种:

* 虚拟机栈(栈帧中的本地变量表)中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中JNI(即一般说的Native方法)引用的对象。

即使在可达性分析算法中不可达的对象,也并非是“非死不可”的,这时候它们暂时处于“缓刑”阶段,要真正宣告一个对象死亡,至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)


### 4.是否可以手动回收

不能手动回收，只能建议

### 5.不可以手动回收，这个方法有什么用

### 6.cglib和jdk proxy区别

jdk动态代理是由java内部的**反射机制**来实现的，cglib动态代理底层则是借助asm（ASM是一个java字节码操纵框架）来实现的。总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。

扩展：java动态代理和静态代理

按照代理的创建时期，代理类可以分为两种：

静态：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。

动态：在程序运行时运用反射机制动态创建而成。

### 7.StringBuffer和StringBuilder的区别

StringBufferd支持并发操作，线性安全的，适合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用

### 7.1.String的+和StringBuilder有什么区别? 放在循环中有什么问题？

String对象一经创建就不可以修改，所以String+会产生多个对象，在循环中会产生大量垃圾对象。

StringBuilder是字符数组实现的,利用append实现字符串追加，是一个对象。

### 8.java中的引用有几种?

4种。

* 强引用：强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。

* 弱引用：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象

* 虚引用：如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收

* 软引用：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。

### 9.volatile的作用，如果volatile修饰的对象经过了大量的写，会出现什么问题？

并发环境中确保可见性、顺序性和一致性

### 10.SimpleDateFormat如果是一个全局变量的话，有什么问题？

SimpleDateFormat是非线程安全的

### 11.如何合理的配置java线程池？如CPU密集型的任务，基本线程池应该配置多大？IO密集型的任务，基本线程池应该配置多大？用有界队列好还是无界队列好？任务非常多的时候，使用什么阻塞队列能获取最好的吞吐量？

* 配置线程池时CPU密集型任务可以少配置线程数，大概和机器的cpu核数相当，可以使得每个线程都在执行任务

* IO密集型时，大部分线程都阻塞，故需要多配置线程数，2*cpu核数

* 有界队列和无界队列的配置需区分业务场景，一般情况下配置有界队列，在一些可能会有爆发性增长的情况下使用无界队列

* 任务非常多时，使用非阻塞队列使用CAS操作替代锁可以获得好的吞吐量。

### 12.什么场景下可以使用volatile替换synchronized？

volatile适用于新值不依赖于旧值的情形。

1写N读

单线程修改变量或不依赖当前值，且不与其他变量构成不变性条件时候使用volatile

### 13.为什么Thread类的sleep()和yield()方法是静态的？

Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。

### 14.为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？

当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。
