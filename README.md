# 贱指offer

#待分类问题

### 1.项目使用的框架

Spring data JPA、Spring boot、Spring data Jedis

### 2.有什么优化

### 3.项目遇到的坑

* 缓存不命中时查询数据库，由于是被动缓存，被人利用这个漏洞攻击了。导致数据库连接池占满。解决办法是不命中也缓存一个特殊值“&&”，过期时间较短

* 自己实现阻塞操作时，CPU占用率特别高，sleep(1) 后马上降下来了。

* 缓存集中失效引起的数据库压力。解决办法是设置过期时间+随机值

### 3.1 并发中遇到哪些问题

死锁产生条件：互斥条件，请求与保持条件，不剥夺条件，循环等待条件



### 3.2 职业规划

希望自己将来可以造轮子给别人用。


### 3.3 说说你项目中印象比较深刻的bug

  同3

### 4.如何在项目中使用缓存

读多改少的情况用二级缓存

否则用Redis缓存

### 5.公司项目流程图

### 6.mq在项目中如何使用

   替代部分分布式事务问题，能达到最终一致性

   更新每台机器的一级缓存

### 7.hash一致性分片的好处

### 8.HashMap源码

### 9.put流程

put()方法返回的是`oldValue`或者`null`

不指定容量的构造方法，map.size() = 0, 第一次初始化默认大小时16

```
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }

```

`<<` : 左移运算符，num << 1,相当于num乘以2

`>>` : 右移运算符，num >> 1,相当于num除以2

`>>>`: 无符号右移，忽略符号位，空位都以0补齐

`&`  : 与, 两个操作数中位都为1，结果才为1，否则结果为0

`~`  : 非, 如果位为0，结果是1，如果位为1，结果是0

`|`  : 或, 两个位只要有一个为1，那么结果就是1，否则就为0

`^`  : 异或, 两个操作数的位中，相同则结果为0，不同则结果为1

### 10.线程的5种状态如何切换

线程的5种状态：新建、就绪、运行、阻塞、死亡。

切换：
sleep() :

yield() : 暂停当前正在执行的线程对象，并执行其他线程。

join()  : Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。join() 方法主要是让调用该方法的thread完成run方法里面的东西后， 再执行join()方法后面的代码

扩展：

Object类的wait(), notify(), notifyAll()方法

wait()

Object的wait方法有三个重载方法，其中一个方法wait() 是无限期(一直)等待，直到其它线程调用notify或notifyAll方法唤醒当前的线程；另外两个方法wait(long timeout) 和wait(long timeout, int nanos)允许传入 当前线程在被唤醒之前需要等待的时间，timeout为毫秒数，nanos为纳秒数。

notify()

notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。

notifyAll()

notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。


### 11.线程是否可以重复启动，会有什么后果。

单一线程不能重复启动，否则报`IllegalThreadStateException`

扩展：

Thread.interrupt()方法不会中断一个正在运行的线程。这一方法实际上完成的是，在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，那么，它将接收到一个中断异常（InterruptedException），从而提早地终结被阻塞状态。

### 12.synchronized 和 lock的区别

ReentrantLock 相对于固有锁synchronized，同样是可重入的，在某些vm版本上提供了比固有锁更高的性能，提供了更丰富的锁特性，比如可中断的锁，可等待的锁，平等锁以及非块结构的加锁。从代码上尽量用固有锁，jvm会对固有锁做一定的优化，并且代码可维护和稳定。只有在需要ReentrantLock的一些特性时，可以考虑用ReentrantLock实现。

### 13.悲观锁、乐观锁，如何自己实现一个乐观锁

乐观锁是假设我已经拿到锁，悲观所是我必须拿到锁，前者用CAS，后者用mutex。

### 14.spring aop底层实现方式

### 15.spring事务的实现原理

### 16.事务的特性，4种隔离级别

### 17.http请求可能返回的状态码

### 18.post和get的区别

### ### 19.如何分辨一个对象是否为垃圾

### 20.是否可以手动回收

### 21.不可以手动回收，这个方法有什么用？

### 22.手写单例

### 23.学生表，班级学生关系表，查出所有班级学生大于90分的个数大于10的班级。

### 24.链表的逆转

### 25.一次循环查找出字符串中第一个不重复的字符

### 26.为何离职

### 27.自身优势

### 28.Mysql执行计划

### 29.慢sql

### 30.快排，堆排，归并排序，基数排序

### 31.线程的生命周期

### 32.单例在哪些场景中用到

### 33.线程启动的底层实现

### 34.wait()方法是哪个类的，为什么不把wait()方法放在Thread类，而是Object？

### 35.线程的实现方式

继承Thread类

实现Runnable接口

使用Executor framework (这会创建一个线程池)

### 36.线程池底层是怎么实现的

### 37.线程池的两种创建方式

### 38.讲讲线程池coreSize和max的关系

### 39.线程池拒绝策略

### 40.二分查找

### 41.二叉排序树

### 42.在main方法中怎么调用单例实例

### 43.反射原理

### 44.spring ioc原理

### 45.TCP协议3次握手，4次挥手

### 45.1 TCP为什么是可靠的

### 46.SQL group by、having

### 47.数据库索引

### 48.java集合

### 49.List有哪些实现类，并描述数据结构，Map有哪些实现类，并描述数据结构

### 50.数据库索引

### 51.重写equals方法一定要重写hashcode方法吗

### 52.jvm启动时发生了那些事

### 53.HashMap和HashTable的区别。

HashMap不是线程安全的，HashTable是线程安全的一个Collection,HashMap允许null key和null value，而hashtable不允许。

### 54.TCP窗口是什么

### 55.TCP为什么比UDP慢

### 56.一个用户表 1亿条记录，如何快速找出某1万用户

### 57.算法：链表相交

### 58.如何避免HashMap resize

### 59.画一下线程的流程图

### 60.算法：一中间高两边低的数组找出峰值

### 61.一个数组，有两个数只出现一次，其他元素都出现两次以上，找出这两个数

### 62.HashMap实现原理，get的时间复杂度

### 63.spring 动态代理

### 64.CPU内存和缓存的工作方式

### 65.java 类加载机制

### 66.mysql递归树查询实现语句

### 67.cglib和jdk proxy区别

### 68.类锁，对象锁

### 69.异常结构物

### 70.事务的隔离级别，情景分析

### 71.LinkedHashMap使用场景

### 72.ThreadLocal 应用场景

比如在多线程环境下使用SimpleDateFormat

### 73.同一进程的不同线程，哪些内容可以共享

### 74.字符串格式化，去掉首尾的空格，以及字符串中间连续的空格，但中间的只保留最后一个空格。比如： " i love meituan ",格式化后："ilove meituan”.

### 75.常用linux命令

### 76.单例模式的双重检查锁定写法

### 77.zookeeper原理

### 78.linux软连接和硬链接，如何查看cpu，内存，java。awk，top

### 79.数据库索引，复合索引

### 80.StringBuffer和StringBuilder的区别

### 81.螺旋矩阵算法

### 82.jvm调试，内存优化

### 83.Spring @Autowire和@Resource的区别

### 84.URL长度限制

### 85.volitile关键字作用

### 86.java 深克隆浅克隆

### 87.算法：查找链表倒数第K个节点

### --------------------------------------------------------
### 88.spring 模块划分

### 89.应用上下文的集中实现方式

### 90.FutureTask的实现原理

### 91.awk实现文件合并

### 92.mysql 的锁

### 93.FactoryBean和BeanFactory的区别

### 94.HashMap和ConcurrentHashMap的线程安全问题

### 95.数据库事务的CAS

### 96.约瑟夫环的编程

### 97.中国有100G数据，美国有100G数据，如何对比数据是否一致？

### 98.如何判断链表是否有环

### 99.找出数组中第K大的数

### 100.java中的引用有几种?

4种。

* 强引用：强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。

* 弱引用：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象

* 虚引用：如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收

* 软引用：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。

### 101.Java中的threadlocal是怎么用的? threadlocal中的内部实现是怎么样的? 哪种引用?

### 102.java中的"final"关键字在多线程的语义中，有什么含义

### 103.说说nio的架构，为什么变快了，说说select和buffer都是怎么用的？
            1.在操作系统中的实现原理? 如果都是cpu轮训话，会不会对cpu影响太大?
            2.应用到了linux中的什么特性?

### 104.nio中， 如果不显式的调用 system.gc() 那会出现什么问题？

### 105.jvm的垃圾回收分为哪些种类？每一种都是怎么去实现的？讲述一下G1的回收策略？

### 106.jvm中的参数分为哪些种类，都是做什么的？jvm的监控怎么做？实际项目上线以后的监控怎么做？

### 107.JVM中，如果把堆内存参数配置的超过了本地内存，会怎么样？

### 108.JVM中的内存结构分为哪些方面？

### 109.栈空间是怎么样的？每个线程只有一个栈吗？

### 110.栈空间的内部结构是怎么样的？

### 111.堆内存为什么要设计为分代？

### 112.ArrayList的实现原理，如何测试ArrayList动态分配内存中带来的内存、cpu变化

### 113.ArrayList是不是线程安全的? 怎么实现线程安全的?

### 114.synchronized和lock有什么区别？

### 115.volatile的作用，如果volatile修饰的对象经过了大量的写，会出现什么问题？

### 116.String的+和StringBuilder有什么区别? 放在循环中有什么问题？

### 117.日志打印的过程中，使用String的+操作和使用占位符输出，对性能上有什么区别

### 117.SimpleDateFormat如果是一个全局变量的话，有什么问题？

     SimpleDateFormat是非线程安全的

### 118.HashMap的操作中，直接使用keySet()遍历有什么问题
     EntrySet


### 119.linux中awk命令的使用？

### 120.nginx是多线程还是单线程？

### 121.linux中如何监控和查看内存、cpu情况？

### 122.负载分为哪些类别和层次？你们项目中是怎么用的？

### 123.mq是如何使用的？

### 124.http协议建立连接的过程是怎么样的？

### 125.https建立连接的的过程是怎么样的？

### 126.forward和redirect有什么区别？

### 127.linux如何实现nginx的高性能？有什么特性被应用了？直接来说，就是基于linux的网络编程

### 128.数据流的锁级别，乐观锁和悲观锁的概念，是不是只有悲观锁？

### 129.数据库如何实现事务？

### 130.有没有什么研究深入的技术，或者比较满意的项目？

### 131.CopyOnWriteArrayList 应用场景

那么有没有办法在遍历一个list的时候，还向list中添加元素呢？办法是有的。就是java concurrent包中的CopyOnWriteArrayList。

CopyOnWriteArrayList类最大的特点就是，在对其实例进行修改操作（add/remove等）会新建一个数据并修改，修改完毕之后，再将原来的引用指向新的数组。这样，修改过程没有修改原来的数组。也就没有了ConcurrentModificationException错误。

### 132.如何合理的配置java线程池？如CPU密集型的任务，基本线程池应该配置多大？IO密集型的任务，基本线程池应该配置多大？用有界队列好还是无界队列好？任务非常多的时候，使用什么阻塞队列能获取最好的吞吐量？

* 配置线程池时CPU密集型任务可以少配置线程数，大概和机器的cpu核数相当，可以使得每个线程都在执行任务

* IO密集型时，大部分线程都阻塞，故需要多配置线程数，2*cpu核数

* 有界队列和无界队列的配置需区分业务场景，一般情况下配置有界队列，在一些可能会有爆发性增长的情况下使用无界队列

* 任务非常多时，使用非阻塞队列使用CAS操作替代锁可以获得好的吞吐量。


### 133.如何使用阻塞队列实现一个生产者和消费者模型？请写代码。

生产者负责notify，消费者需要wait，条件是有无元素

BlockingQueue put take

### 134. 如何实现乐观锁（CAS）？如何避免ABA问题？

读取内存值

比较内存值和期望值

替换内存值为要替换值

利用CPU的CAS命令，避免ABA需要使用类似于version，AtomicStampedReference也可以

### 135. 读写锁可以用于什么应用场景？

多读少写，读写锁支持多个读操作并发执行，写操作只能由一个线程来操作

### 136. 什么时候应该使用可重入锁？

重入锁指的是在某一个线程中可以多次获得同一把锁，在线程中多次操作有锁的方法。

需要使用除了内置锁以外的锁特性，比如可中断，可等待的锁，平等锁等

可轮询，可中断，定时，非块，公平队列等高级特性时候使用可重入锁

### 137.什么场景下可以使用volatile替换synchronized？

volatile适用于新值不依赖于就值的情形。

1写N读

单线程修改变量或不依赖当前值，且不与其他变量构成不变性条件时候使用volatile

### 138.为什么Thread类的sleep()和yield()方法是静态的？

Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。

### 139.为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？

当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。
